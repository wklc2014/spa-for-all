<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>underscore.js</title>
  <meta name="description" content="">
  <meta name="keywords" content="">
  <link rel="stylesheet" type="text/css" href="css/css.css">
  <script src="js/underscore-v1.9.1.min.js" type="text/javascript" charset="utf-8" async defer></script>
</head>

<body>
  <div id="sidebar" class="interface">
    <a class="toc_title" href="#">
      Underscore.js <span class="version">(1.9.1)</span>
    </a>
    <div class="searchable_section">
      <a class="toc_title" href="#">介绍(Introduction)</a>
    </div>
    <div class="searchable_section">
      <a class="toc_title" href="#collections">集合(Collections)</a>
      <ul class="toc_section">
        <li data-name="each" data-aliases="forEach">- <a href="#each">each</a></li>
        <li data-name="map" data-aliases="collect">- <a href="#map">map</a></li>
        <li data-name="reduce" data-aliases="inject foldl">- <a href="#reduce">reduce</a></li>
        <li data-name="reduceRight" data-aliases="foldr">- <a href="#reduceRight">reduceRight</a></li>
        <li data-name="find" data-aliases="detect">- <a href="#find">find</a></li>
        <li data-name="filter" data-aliases="select">- <a href="#filter">filter</a></li>
        <li data-name="where">- <a href="#where">where</a></li>
        <li data-name="findWhere">- <a href="#findWhere">findWhere</a></li>
        <li data-name="reject">- <a href="#reject">reject</a></li>
        <li data-name="every" data-aliases="all">- <a href="#every">every</a></li>
        <li data-name="some" data-aliases="any">- <a href="#some">some</a></li>
        <li data-name="contains" data-aliases="include includes">- <a href="#contains">contains</a></li>
        <li data-name="invoke">- <a href="#invoke">invoke</a></li>
        <li data-name="pluck">- <a href="#pluck">pluck</a></li>
        <li data-name="max">- <a href="#max">max</a></li>
        <li data-name="min">- <a href="#min">min</a></li>
        <li data-name="sortBy">- <a href="#sortBy">sortBy</a></li>
        <li data-name="groupBy">- <a href="#groupBy">groupBy</a></li>
        <li data-name="indexBy">- <a href="#indexBy">indexBy</a></li>
        <li data-name="countBy">- <a href="#countBy">countBy</a></li>
        <li data-name="shuffle">- <a href="#shuffle">shuffle</a></li>
        <li data-name="sample">- <a href="#sample">sample</a></li>
        <li data-name="toArray">- <a href="#toArray">toArray</a></li>
        <li data-name="size">- <a href="#size">size</a></li>
        <li data-name="partition">- <a href="#partition">partition</a></li>
      </ul>
    </div>
    <div class="searchable_section">
      <a class="toc_title" href="#arrays">数组(Arrays)</a>
      <ul class="toc_section">
        <li data-name="first" data-aliases="head take">- <a href="#first">first</a></li>
        <li data-name="initial">- <a href="#initial">initial</a></li>
        <li data-name="last">- <a href="#last">last</a></li>
        <li data-name="rest" data-aliases="tail drop">- <a href="#rest">rest</a></li>
        <li data-name="compact">- <a href="#compact">compact</a></li>
        <li data-name="flatten">- <a href="#flatten">flatten</a></li>
        <li data-name="without">- <a href="#without">without</a></li>
        <li data-name="union">- <a href="#union">union</a></li>
        <li data-name="intersection">- <a href="#intersection">intersection</a></li>
        <li data-name="difference">- <a href="#difference">difference</a></li>
        <li data-name="uniq" data-aliases="unique">- <a href="#uniq">uniq</a></li>
        <li data-name="zip">- <a href="#zip">zip</a></li>
        <li data-name="unzip">- <a href="#unzip">unzip</a></li>
        <li data-name="object">- <a href="#object">object</a></li>
        <li data-name="chunk">- <a href="#chunk">chunk</a></li>
        <li data-name="indexOf">- <a href="#indexOf">indexOf</a></li>
        <li data-name="lastIndexOf">- <a href="#lastIndexOf">lastIndexOf</a></li>
        <li data-name="sortedIndex">- <a href="#sortedIndex">sortedIndex</a></li>
        <li data-name="findIndex">- <a href="#findIndex">findIndex</a></li>
        <li data-name="findLastIndex">- <a href="#findLastIndex">findLastIndex</a></li>
        <li data-name="range">- <a href="#range">range</a></li>
      </ul>
    </div>
    <div class="searchable_section">
      <a class="toc_title" href="#functions">函数(Functions)</a>
      <ul class="toc_section">
        <li data-name="bind">- <a href="#bind">bind</a></li>
        <li data-name="bindAll">- <a href="#bindAll">bindAll</a></li>
        <li data-name="partial">- <a href="#partial">partial</a></li>
        <li data-name="memoize">- <a href="#memoize">memoize</a></li>
        <li data-name="delay">- <a href="#delay">delay</a></li>
        <li data-name="defer">- <a href="#defer">defer</a></li>
        <li data-name="throttle">- <a href="#throttle">throttle</a></li>
        <li data-name="debounce">- <a href="#debounce">debounce</a></li>
        <li data-name="once">- <a href="#once">once</a></li>
        <li data-name="after">- <a href="#after">after</a></li>
        <li data-name="before">- <a href="#before">before</a></li>
        <li data-name="wrap">- <a href="#wrap">wrap</a></li>
        <li data-name="negate">- <a href="#negate">negate</a></li>
        <li data-name="compose">- <a href="#compose">compose</a></li>
        <li data-name="restArguments">- <a href="#restArguments">restArguments</a></li>
      </ul>
    </div>
    <div class="searchable_section">
      <a class="toc_title" href="#objects">对象(Objects)</a>
      <ul class="toc_section">
        <li data-name="keys">- <a href="#keys">keys</a></li>
        <li data-name="allKeys">- <a href="#allKeys">allKeys</a></li>
        <li data-name="values">- <a href="#values">values</a></li>
        <li data-name="mapObject">- <a href="#mapObject">mapObject</a></li>
        <li data-name="pairs">- <a href="#pairs">pairs</a></li>
        <li data-name="invert">- <a href="#invert">invert</a></li>
        <li data-name="create">- <a href="#create">create</a></li>
        <li data-name="object-functions" data-aliases="methods">- <a href="#object-functions">functions</a></li>
        <li data-name="findKey">- <a href="#findKey">findKey</a></li>
        <li data-name="extend">- <a href="#extend">extend</a></li>
        <li data-name="extendOwn" data-aliases="assign">- <a href="#extendOwn">extendOwn</a></li>
        <li data-name="pick">- <a href="#pick">pick</a></li>
        <li data-name="omit">- <a href="#omit">omit</a></li>
        <li data-name="defaults">- <a href="#defaults">defaults</a></li>
        <li data-name="clone">- <a href="#clone">clone</a></li>
        <li data-name="tap">- <a href="#tap">tap</a></li>
        <li data-name="has">- <a href="#has">has</a></li>
        <li data-name="property">- <a href="#property">property</a></li>
        <li data-name="propertyOf">- <a href="#propertyOf">propertyOf</a></li>
        <li data-name="matcher">- <a href="#matcher">matcher</a></li>
        <li data-name="isEqual">- <a href="#isEqual">isEqual</a></li>
        <li data-name="isMatch">- <a href="#isMatch">isMatch</a></li>
        <li data-name="isEmpty">- <a href="#isEmpty">isEmpty</a></li>
        <li data-name="isElement">- <a href="#isElement">isElement</a></li>
        <li data-name="isArray">- <a href="#isArray">isArray</a></li>
        <li data-name="isObject">- <a href="#isObject">isObject</a></li>
        <li data-name="isArguments">- <a href="#isArguments">isArguments</a></li>
        <li data-name="isFunction">- <a href="#isFunction">isFunction</a></li>
        <li data-name="isString">- <a href="#isString">isString</a></li>
        <li data-name="isNumber">- <a href="#isNumber">isNumber</a></li>
        <li data-name="isFinite">- <a href="#isFinite">isFinite</a></li>
        <li data-name="isBoolean">- <a href="#isBoolean">isBoolean</a></li>
        <li data-name="isDate">- <a href="#isDate">isDate</a></li>
        <li data-name="isRegExp">- <a href="#isRegExp">isRegExp</a></li>
        <li data-name="isError">- <a href="#isError">isError</a></li>
        <li data-name="isSymbol">- <a href="#isSymbol">isSymbol</a></li>
        <li data-name="isMap">- <a href="#isMap">isMap</a></li>
        <li data-name="isWeakMap">- <a href="#isWeakMap">isWeakMap</a></li>
        <li data-name="isSet">- <a href="#isSet">isSet</a></li>
        <li data-name="isWeakSet">- <a href="#isWeakSet">isWeakSet</a></li>
        <li data-name="isNaN">- <a href="#isNaN">isNaN</a></li>
        <li data-name="isNull">- <a href="#isNull">isNull</a></li>
        <li data-name="isUndefined">- <a href="#isUndefined">isUndefined</a></li>
      </ul>
    </div>
    <div class="searchable_section">
      <a class="toc_title" href="#utility">实用功能(Utility)</a>
      <ul class="toc_section">
        <li data-name="noConflict">- <a href="#noConflict">noConflict</a></li>
        <li data-name="identity">- <a href="#identity">identity</a></li>
        <li data-name="constant">- <a href="#constant">constant</a></li>
        <li data-name="noop">- <a href="#noop">noop</a></li>
        <li data-name="times">- <a href="#times">times</a></li>
        <li data-name="random">- <a href="#random">random</a></li>
        <li data-name="mixin">- <a href="#mixin">mixin</a></li>
        <li data-name="iteratee">- <a href="#iteratee">iteratee</a></li>
        <li data-name="uniqueId">- <a href="#uniqueId">uniqueId</a></li>
        <li data-name="escape">- <a href="#escape">escape</a></li>
        <li data-name="unescape">- <a href="#unescape">unescape</a></li>
        <li data-name="result">- <a href="#result">result</a></li>
        <li data-name="now">- <a href="#now">now</a></li>
        <li data-name="template">- <a href="#template">template</a></li>
      </ul>
    </div>
    <div class="searchable_section">
      <a class="toc_title" href="#oop">OOP Style</a>
    </div>
    <div class="searchable_section">
      <a class="toc_title" href="#chaining">链式语法(Chaining)</a>
      <ul class="toc_section">
        <li data-name="chain">- <a href="#chain">chain</a></li>
        <li data-name="value">- <a href="#value">value</a></li>
      </ul>
    </div>
    <div class="searchable_section">
      <a class="toc_title" href="#links">更多链接(Links)</a>
    </div>
    <div class="searchable_section">
      <a class="toc_title" href="#changelog">更新日志(Change Log)</a>
    </div>
  </div>
  <div class="container">
    <p id="introduction">
      <img id="logo" src="images/underscore.png" alt="Underscore.js">
    </p>
    <p>本文档为Underscore.js (1.9.1) 中文文档</p>
		<p>
			<a href="http://github.com/jashkenas/underscore/">Underscore</a>一个JavaScript实用库，提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。它是这个问题的答案：“如果我在一个空白的HTML页面前坐下， 并希望立即开始工作， 我需要什么？“它弥补了部分<a href="http://docs.jquery.com">jQuery</a>没有实现的功能,同时又是<a href="http://backbonejs.org">Backbone.js</a>必不可少的部分。 （感谢<a href="http://weibo.com/xiaodengzidaj" target="_blank">@小邓子daj </a> 的翻译建议）
		</p>
		<p>
		Underscore提供了100多个函数,包括常用的: <b>map</b>, <b>filter</b>, <b>invoke</b> — 当然还有更多专业的辅助函数,如:函数绑定,
		JavaScript模板功能,创建快速索引, 强类型相等测试, 等等.
		</p>
		<p>该项目代码<a href="http://github.com/documentcloud/underscore/">托管在GitHub</a>上。您可以在<a href="https://github.com/jashkenas/underscore/issues">issues
		页面</a>上报告错误或讨论功能，或在 <a href="https://gitter.im/jashkenas/underscore">Gitter</a> 通道中和我们聊。
		</p>
		<h2>安装（Installation）</h2>
		<ul>
  		<li>
  	    <b>Node.js</b> <tt>npm install underscore</tt>
  		</li>
  		<li>
  	    <b>Meteor.js</b> <tt>meteor add underscore</tt>
  		</li>
  		<li>
  	    <b>Require.js</b> <tt>require(["underscore"], ...</tt>
  		</li>
  		<li>
  	    <b>Bower</b> <tt>bower install underscore</tt>
  		</li>
  		<li>
  	    <b>Component</b> <tt>component install jashkenas/underscore</tt>
  		</li>
		</ul>
		<div id="documentation">
      <h2 id="collections">集合函数  (数组 或对象)</h2>
      <p id="each">
        <b class="header">each</b><code>_.each(list, iteratee, [context])</code>
        <span class="alias">Alias: <b>forEach</b></span>
        <br>
        遍历<b>list</b>中的所有元素，按顺序用每个元素当做参数调用 <b>iteratee</b> 函数。如果传递了<b>context</b>参数，则把<b>iteratee</b>绑定到<b>context</b>对象上。每次调用<b>iteratee</b>都会传递三个参数：<tt>(element, index, list)</tt>。如果<b>list</b>是个JavaScript对象，<b>iteratee</b>的参数是 <tt>(value, key, list)</tt>)。返回<b>list</b>以方便链式调用。
      </p>
      <pre>_.each([1, 2, 3], alert);
=&gt; alerts each number in turn...
_.each({one: 1, two: 2, three: 3}, alert);
=&gt; alerts each number value in turn...</pre>
      <p>
        <i>
        注意：集合函数能在数组，对象，和类数组对象，比如</i><tt>arguments</tt>, <tt>NodeList</tt><i>和类似的数据类型上正常工作。 但是它通过<a href="http://zh.wikipedia.org/zh-cn/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B" target="_blank">鸭子类型</a>工作，所以要避免传递带有一个数值类型 <tt>length</tt> 属性的对象。每个循环不能被破坏 - 打破， 使用<b>_.find</b>代替，这也是很好的注意。
      </i>
    </p>
    <p id="map">
        <b class="header">map</b><code>_.map(list, iteratee, [context])</code>
        <span class="alias">Alias: <b>collect</b></span>
        <br>
        通过对 <b>list</b> 里的每个元素调用转换函数(<a href="#iteratee"><b>iteratee</b></a>迭代器)生成一个与之相对应的数组。<tt>iteratee</tt>传递三个参数：<tt>value</tt>，然后是迭代 <tt>index</tt>(或 <tt>key</tt> 注：如果<b>list</b>是个JavaScript对象是，这个参数就是<tt>key</tt>)，最后一个是引用指向整个<tt>list</tt>。
    </p>
    <pre>_.map([1, 2, 3], function(num){ return num * 3; });
=&gt; [3, 6, 9]
_.map({one: 1, two: 2, three: 3}, function(num, key){ return num * 3; });
=&gt; [3, 6, 9]
_.map([[1, 2], [3, 4]], _.first);
=&gt; [1, 3]</pre>
    <p id="reduce">
        <b class="header">reduce</b><code>_.reduce(list, iteratee, [memo], [context])</code>
        <span class="alias">Aliases: <b>inject</b>, <b>foldl</b></span>
        <br>
        别名为 <b>inject</b> 和 <b>foldl</b>, <b>reduce</b>方法把<b>list</b>中元素归结为一个单独的数值。<b>Memo</b>是reduce函数的初始值，会被每一次成功调用<b>iteratee</b>函数的返回值所取代
        。这个迭代传递4个参数：<tt>memo</tt>,<tt>value</tt> 和 迭代的<tt>index</tt>（或者 key）和最后一个引用的整个 <tt>list</tt>。
    </p>
    <p>
        如果没有<b>memo</b>传递给<b>reduce</b>的初始调用，<b>iteratee</b>不会被列表中的第一个元素调用。第一个元素将取代<b>memo</b>参数传递给列表中下一个元素调用的<b>iteratee</b>函数。
    </p>
    <pre>var sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num; }, 0);
=&gt; 6</pre>
    <p id="reduceRight">
        <b class="header">reduceRight</b><code>_.reduceRight(list, iteratee, [memo], [context])</code>
        <span class="alias">Alias: <b>foldr</b></span>
        <br>
        <b>reducRight</b>是从右侧开始组合元素的<b>reduce</b>函数， <b>Foldr</b>在 JavaScript 中不像其它有惰性求值的语言那么有用（注：lazy evaluation：一种求值策略，只有当表达式的值真正需要时才对表达式进行计算）。
    </p>
    <pre>var list = [[0, 1], [2, 3], [4, 5]];
var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
=&gt; [4, 5, 2, 3, 0, 1]</pre>
    <p id="find">
        <b class="header">find</b><code>_.find(list, predicate, [context])</code>
        <span class="alias">Alias: <b>detect</b></span>
        <br>
        在<b>list</b>中逐项查找，返回第一个通过<b>predicate</b>迭代函数真值检测的元素值，如果没有元素通过检测则返回 <code>undefined</code>。
        如果找到匹配的元素，函数将立即返回，不会遍历整个list。
        <b>predicate</b> 通过 <a href="#iteratee"><b>iteratee</b></a> 进行转换，以简化速记语法。
    </p>
    <pre>var even = _.find([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
=&gt; 2</pre>
    <p id="filter">
        <b class="header">filter</b><code>_.filter(list, predicate, [context])</code>
        <span class="alias">Alias: <b>select</b></span>
        <br>
        遍历<b>list</b>中的每个值，返回所有通过<b>predicate</b>真值检测的元素所组成的数组。
        <b>predicate</b> 通过 <a href="#iteratee"><b>iteratee</b></a> 进行转换，以简化速记语法。
    </p>
    <pre>var evens = _.filter([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
=&gt; [2, 4, 6]</pre>
    <p id="findWhere">
        <b class="header">findWhere</b><code>_.findWhere(list, properties)</code>
        <br>
        遍历整个<b>list</b>，返回 <a href="#matches">matches（匹配）</a> <b>properties</b>参数所列出的所有 键 - 值 对的第一个值。
    </p>
    <p>
        如果没有找到匹配的属性，或者<b>list</b>是空的，那么将返回<i>undefined</i>。
    </p>
    <pre>_.findWhere(publicServicePulitzers, {newsroom: "The New York Times"});
=&gt; {year: 1918, newsroom: "The New York Times",
reason: "For its public service in publishing in full so many official reports,
documents and speeches by European statesmen relating to the progress and
conduct of the war."}</pre>
    <p id="where">
        <b class="header">where</b><code>_.where(list, properties)</code>
        <br>
        遍历<b>list</b>中的每一个值，返回一个数组，这个数组里的元素包含 <b>properties</b> 所列出的键 - 值对。
    </p>
    <pre>_.where(listOfPlays, {author: "Shakespeare", year: 1611});
=&gt; [{title: "Cymbeline", author: "Shakespeare", year: 1611},
{title: "The Tempest", author: "Shakespeare", year: 1611}]</pre>
    <p id="reject">
        <b class="header">reject</b><code>_.reject(list, predicate, [context])</code>
        <br>
        返回<b>list</b>中没有通过<b>predicate</b>真值检测的元素集合，与<b>filter</b>相反。
        <b>predicate</b> 通过 <a href="#iteratee"><b>iteratee</b></a> 进行转换，以简化速记语法。
    </p>
    <pre>var odds = _.reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
=&gt; [1, 3, 5]</pre>
    <p id="every">
        <b class="header">every</b><code>_.every(list, [predicate], [context])</code>
        <span class="alias">Alias: <b>all</b></span>
        <br>
        如果<b>list</b>中的所有元素都通过<b>predicate</b>的真值检测就返回<i>true</i>。（注：如果存在原生的<b>every</b>方法，就使用原生的<b>every</b>。）
        <b>predicate</b> 通过 <a href="#iteratee"><b>iteratee</b></a> 进行转换，以简化速记语法。
    </p>
    <pre>_.every([2, 4, 5], function(num) { return num % 2 == 0; });
=&gt; false</pre>
    <p id="some">
        <b class="header">some</b><code>_.some(list, [predicate], [context])</code>
        <span class="alias">Alias: <b>any</b></span>
        <br>
        如果<b>list</b>中有任何一个元素通过 <b>predicate</b> 的真值检测就返回<i>true</i>。一旦找到了符合条件的元素, 就直接中断对list的遍历。
        <b>predicate</b> 通过 <a href="#iteratee"><b>iteratee</b></a> 进行转换，以简化速记语法。
    </p>
    <pre>_.some([null, 0, 'yes', false]);
=&gt; true</pre>
    <p id="contains">
        <b class="header">contains</b><code>_.contains(list, value, [fromIndex])</code>
        <span class="alias">Aliases: <b>include</b>, <b>includes</b></span>
        <br>
        如果<b>list</b>包含指定的<b>value</b>则返回<i>true</i>（注：使用===检测）。如果<b>list</b> 是数组，内部使用<b>indexOf</b>判断。使用<b>fromIndex</b>来给定开始检索的索引位置。
    </p>
    <pre>_.contains([1, 2, 3], 3);
=&gt; true</pre>
    <p id="invoke">
        <b class="header">invoke</b><code>_.invoke(list, methodName, *arguments)</code>
        <br>
        在<b>list</b>的每个元素上执行<b>methodName</b>方法。
        任何传递给<b>invoke</b>的额外参数，<b>invoke</b>都会在调用<b>methodName</b>方法的时候传递给它。
    </p>
    <pre>_.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
=&gt; [[1, 5, 7], [1, 2, 3]]</pre>
    <p id="pluck">
        <b class="header">pluck</b><code>_.pluck(list, propertyName)</code>
        <br>
        <b>pluck</b>也许是<b>map</b>最常使用的用例模型的简化版本，即萃取数组对象中某属性值，返回一个数组。
    </p>
    <pre>var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
_.pluck(stooges, 'name');
=&gt; ["moe", "larry", "curly"]</pre>
    <p id="max">
        <b class="header">max</b><code>_.max(list, [iteratee], [context])</code>
        <br>
        返回<b>list</b>中的最大值。如果传递<b>iteratee</b>参数，<b>iteratee</b>将作为<b>list</b>中每个值的排序依据。如果<b>list</b>为空，将返回<i>-Infinity</i>，所以你可能需要事先用<a href="#isEmpty">isEmpty</a>检查 <b>list</b> 。
    </p>
    <pre>var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
_.max(stooges, function(stooge){ return stooge.age; });
=&gt; {name: 'curly', age: 60};</pre>
    <p id="min">
        <b class="header">min</b><code>_.min(list, [iteratee], [context])</code>
        <br>
        返回<b>list</b>中的最小值。如果传递<b>iteratee</b>参数，<b>iteratee</b>将作为<b>list</b>中每个值的排序依据。如果<b>list</b>为空，将返回<i>Infinity</i>，所以你可能需要事先用<a href="#isEmpty">isEmpty</a>检查 <b>list</b> 。
    </p>
    <pre>var numbers = [10, 5, 100, 2, 1000];
_.min(numbers);
=&gt; 2</pre>
    <p id="sortBy">
        <b class="header">sortBy</b><code>_.sortBy(list, iteratee, [context])</code>
        <br>
        返回一个（稳定的）排序后的<b>list</b>拷贝副本。如果传递<b>iteratee</b>参数，<b>iteratee</b>将作为<b>list</b>中每个值的排序依据。用来进行排序迭代器也可以是属性名称的字符串(比如 <tt>length</tt>)。
    </p>
    <pre>_.sortBy([1, 2, 3, 4, 5, 6], function(num){ return Math.sin(num); });
=&gt; [5, 4, 6, 3, 1, 2]

var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
_.sortBy(stooges, 'name');
=&gt; [{name: 'curly', age: 60}, {name: 'larry', age: 50}, {name: 'moe', age: 40}];</pre>
    <p id="groupBy">
        <b class="header">groupBy</b><code>_.groupBy(list, iteratee, [context])</code>
        <br>
        把一个集合分组为多个集合，通过 <b>iterator</b> 返回的结果进行分组. 如果 <b>iterator</b> 是一个字符串而不是函数, 那么将使用 <b>iterator</b> 作为各元素的属性名来对比进行分组。
    </p>
    <pre>_.groupBy([1.3, 2.1, 2.4], function(num){ return Math.floor(num); });
=&gt; {1: [1.3], 2: [2.1, 2.4]}

_.groupBy(['one', 'two', 'three'], 'length');
=&gt; {3: ["one", "two"], 5: ["three"]}</pre>
    <p id="indexBy">
        <b class="header">indexBy</b><code>_.indexBy(list, iteratee, [context])</code>
        <br>
        给定一个<b>list</b>，和 一个用来返回一个在列表中的每个元素键 的<b>iterator</b> 函数（或属性名），
        返回一个每一项索引的对象。和<a href="#groupBy">groupBy</a>非常像，但是当你知道你的键是唯一的时候可以使用<b>indexBy</b> 。
    </p>
    <pre>var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
_.indexBy(stooges, 'age');
=&gt; {
  "40": {name: 'moe', age: 40},
  "50": {name: 'larry', age: 50},
  "60": {name: 'curly', age: 60}
}</pre>
    <p id="countBy">
        <b class="header">countBy</b><code>_.countBy(list, iteratee, [context])</code>
        <br>
        排序一个列表组成多个组，并且返回各组中的对象的数量的计数。类似<tt>groupBy</tt>，但是不是返回列表的值，而是返回在该组中值的数目。
    </p>
    <pre>_.countBy([1, 2, 3, 4, 5], function(num) {
return num % 2 == 0 ? 'even': 'odd';
});
=&gt; {odd: 3, even: 2}</pre>
    <p id="shuffle">
        <b class="header">shuffle</b><code>_.shuffle(list)</code>
        <br>
        返回一个随机乱序的 <b>list</b> 副本, 使用
        <a href="http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a> 来进行随机乱序.
    </p>
    <pre>_.shuffle([1, 2, 3, 4, 5, 6]);
=&gt; [4, 1, 6, 3, 5, 2]</pre>
    <p id="sample">
        <b class="header">sample</b><code>_.sample(list, [n])</code>
        <br>
        从 <b>list</b>中产生一个随机样本。传递一个数字表示从<b>list</b>中返回<b>n</b>个随机元素。否则将返回一个单一的随机项。
    </p>
    <pre>_.sample([1, 2, 3, 4, 5, 6]);
=&gt; 4

_.sample([1, 2, 3, 4, 5, 6], 3);
=&gt; [1, 6, 2]</pre>
    <p id="toArray">
        <b class="header">toArray</b><code>_.toArray(list)</code>
        <br>
        把<b>list</b>(任何可以迭代的对象)转换成一个数组，在转换 <b>arguments</b> 对象时非常有用。
    </p>
    <pre>(function(){ return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
=&gt; [2, 3, 4]</pre>
    <p id="size">
        <b class="header">size</b><code>_.size(list)</code>
        <br>
        返回<b>list</b>的长度。
    </p>
    <pre>_.size([1, 2, 3, 4, 5]);
=&gt; 5

_.size({one: 1, two: 2, three: 3});
=&gt; 3</pre>
    <p id="partition">
        <b class="header">partition</b><code>_.partition(list, predicate)</code>
        <br>
        将 <b>list</b> 拆分为两个数组：第一个数组其元素都满足<b>predicate</b>迭代函数， 而第二个的所有元素均不能满足<b>predicate</b>迭代函数。
        <b>predicate</b> 通过 <a href="#iteratee"><b>iteratee</b></a> 进行转换，以简化速记语法。
    </p>
    <pre>_.partition([0, 1, 2, 3, 4, 5], isOdd);
=&gt; [[1, 3, 5], [0, 2, 4]]</pre>
    <p id="compact">
        <b class="header">compact</b><code>_.compact(list)</code>
        <br>
        返回一个除去了所有 falsy(假) 值的 <b>list</b> 副本。
        在javascript中, <i>false</i>, <i>null</i>, <i>0</i>, <i>""</i>,
        <i>undefined</i> 和 <i>NaN</i> 都是falsy(假)值.
    </p>
    <pre>_.compact([0, 1, false, 2, '', 3]);
=&gt; [1, 2, 3]</pre>
    <h2 id="arrays">数组函数（Array Functions）</h2>
    <p>
        <i>注： 所有的数组函数也可以用于 <b>arguments</b> (参数)对象。 但是，Underscore 函数不能用于稀疏（"sparse" ）数组。</i>
    </p>
    <p id="first">
        <b class="header">first</b><code>_.first(array, [n])</code>
        <span class="alias">Aliases: <b>head</b>, <b>take</b></span>
        <br>
        返回<b>array</b> （数组）的第一个元素。传递 <b>n</b>参数将返回数组中从第一个元素开始的<b>n</b>个元素（注：返回数组中前 <b>n</b> 个元素.）。
    </p>
    <pre>_.first([5, 4, 3, 2, 1]);
=&gt; 5</pre>
    <p id="initial">
        <b class="header">initial</b><code>_.initial(array, [n])</code>
        <br>
        返回数组中除了最后一个元素外的其他全部元素。 在arguments对象上特别有用。传递 <b>n</b>参数将从结果中排除从最后一个开始的<b>n</b>个元素（注：排除数组后面的 <b>n</b> 个元素）。
    </p>
    <pre>_.initial([5, 4, 3, 2, 1]);
=&gt; [5, 4, 3, 2]</pre>
    <p id="last">
        <b class="header">last</b><code>_.last(array, [n])</code>
        <br>
        返回<b>array</b>（数组）中最后一个元素。传递 <b>n</b>参数将返回数组中从最后一个元素开始的<b>n</b>个元素（注：返回数组里的后面的<b>n</b>个元素）。
    </p>
    <pre>_.last([5, 4, 3, 2, 1]);
=&gt; 1</pre>
    <p id="rest">
        <b class="header">rest</b><code>_.rest(array, [index])</code>
        <span class="alias">Aliases: <b>tail</b>, <b>drop</b></span>
        <br>
        返回数组中除了第一个元素外的其他全部元素。传递 <b>index</b> 参数将返回从<b>index</b>开始的剩余所有元素 。（感谢<a href="http://weibo.com/heerake" target="_blank">@德德德德撸</a> 指出错误）
    </p>
    <pre>_.rest([5, 4, 3, 2, 1]);
=&gt; [4, 3, 2, 1]</pre>
    <p id="flatten">
        <b class="header">flatten</b><code>_.flatten(array, [shallow])</code>
        <br>
        将一个嵌套多层的数组 <b>array（数组）</b> (嵌套可以是任何层数)转换为只有一层的数组。
        如果你传递 <b>shallow</b>参数，数组将只减少一维的嵌套。
    </p>
    <pre>_.flatten([1, [2], [3, [[4]]]]);
=&gt; [1, 2, 3, 4];

_.flatten([1, [2], [3, [[4]]]], true);
=&gt; [1, 2, 3, [[4]]];</pre>
    <p id="without">
        <b class="header">without</b><code>_.without(array, *values)</code>
        <br>
        返回一个删除所有<b>values</b>值后的 <b>array</b>副本。（注：使用<i>===</i>表达式做相等测试。）
    </p>
    <pre>_.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
=&gt; [2, 3, 4]</pre>
    <p id="union">
        <b class="header">union</b><code>_.union(*arrays)</code>
        <br>
        返回传入的 <b>arrays（数组）</b>并集：按顺序返回，返回数组的元素是唯一的，可以传入一个或多个 <b>arrays</b> （数组）。
    </p>
    <pre>_.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
=&gt; [1, 2, 3, 101, 10]</pre>
    <p id="intersection">
        <b class="header">intersection</b><code>_.intersection(*arrays)</code>
        <br>
        返回传入 <b>arrays</b>（数组）交集。结果中的每个值是存在于传入的每个<b>arrays</b>（数组）里。
    </p>
    <pre>_.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
=&gt; [1, 2]</pre>
    <p id="difference">
        <b class="header">difference</b><code>_.difference(array, *others)</code>
        <br>
        类似于<b>without</b>，但返回的值来自<b>array</b>参数数组，并且不存在于<b>other</b> 数组。
    </p>
    <pre>_.difference([1, 2, 3, 4, 5], [5, 2, 10]);
=&gt; [1, 3, 4]</pre>
    <p id="uniq">
        <b class="header">uniq</b><code>_.uniq(array, [isSorted], [iteratee])</code>
        <span class="alias">Alias: <b>unique</b></span>
        <br>
        返回 <b>array</b>去重后的副本, 使用 <i>===</i> 做相等测试. 如果您确定 <b>array</b> 已经排序, 那么给 <b>isSorted</b> 参数传递 <i>true</i>值, 此函数将运行的更快的算法. 如果要处理对象元素, 传递 <a href="#iteratee"><b>iteratee</b></a>函数来获取要对比的属性。
    </p>
    <pre>_.uniq([1, 2, 1, 4, 1, 3]);
=&gt; [1, 2, 4, 3]</pre>
    <p id="zip">
        <b class="header">zip</b><code>_.zip(*arrays)</code>
        <br>
        将每个 <b>arrays</b> 中相应位置的值合并在一起。 当您有通过匹配数组索引进行协调的独立数据源时，这非常有用。 结合 <tt>apply</tt> 一起使用传入一个二维数组。 如果你用来处理矩阵嵌套数组时，则可以使用它来转换矩阵。
    </p>
    <pre>_.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);
=&gt; [["moe", 30, true], ["larry", 40, false], ["curly", 50, false]]</pre>
    <p id="unzip">
        <b class="header">unzip</b><code>_.unzip(array)</code>
        <br>
        与<a href="#zip">zip</a>功能相反的函数，给定若干<b>arrays</b>，返回一串联的新数组，其第一元素个包含所有的输入数组的第一元素，其第二包含了所有的第二元素，依此类推。（感谢 <a href="http://weibo.com/wenbin1986" target="_blank">@周文彬1986</a>、 <a href="http://weibo.com/u/2154096382" target="_blank">@未定的终点</a> 指出示例错误）。
    </p>
    <pre>_.unzip([["moe", 30, true], ["larry", 40, false], ["curly", 50, false]]);
=&gt; [['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]]</pre>
    <p id="object">
        <b class="header">object</b><code>_.object(list, [values])</code>
        <br>
        将数组转换为对象。传递任何一个单独<tt>[key, value]</tt>对的列表，或者一个键的列表和一个值得列表。成对（Pairs）传递 则是 <a href="#pairs">pairs</a> 的反函数。
        如果存在重复键，最后一个值将被返回。
    </p>
    <pre>_.object(['moe', 'larry', 'curly'], [30, 40, 50]);
=&gt; {moe: 30, larry: 40, curly: 50}

_.object([['moe', 30], ['larry', 40], ['curly', 50]]);
=&gt; {moe: 30, larry: 40, curly: 50}</pre>
    <p id="chunk">
        <b class="header">chunk</b><code>_.chunk(array, length)</code>
        <br>
        将 <b>array</b> 分成多个数组，每个数组包含<b>length</b> 或更少的项。
    </p>
    <pre>var partners = _.chunk(_.shuffle(kindergarten), 2);
=&gt; [["Tyrone", "Elie"], ["Aidan", "Sam"], ["Katrina", "Billie"], ["Little Timmy"]]</pre>
    <p id="indexOf">
        <b class="header">indexOf</b><code>_.indexOf(array, value, [isSorted])</code>
        <br>
        返回<b>value</b>在该 <b>array</b> 中的索引值，如果<b>value</b>不存在 <b>array</b>中就返回<i>-1</i>。使用原生的<b>indexOf</b> 函数，除非它失效。如果您正在使用一个大数组，你知道数组已经排序，传递<tt>true</tt>给<b>isSorted</b>将更快的用二进制搜索..,或者，传递一个数字作为第三个参数，为了在给定的索引的数组中寻找第一个匹配值。
    </p>
    <pre>_.indexOf([1, 2, 3], 2);
=&gt; 1</pre>
    <p id="lastIndexOf">
        <b class="header">lastIndexOf</b><code>_.lastIndexOf(array, value, [fromIndex])</code>
        <br>
        返回<b>value</b>在该 <b>array</b> 中的从最后开始的索引值，如果<b>value</b>不存在 <b>array</b>中就返回<i>-1</i>。传递<b>fromIndex</b>将从你给定的索性值开始搜索。
    </p>
    <pre>_.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
=&gt; 4</pre>
    <p id="sortedIndex">
        <b class="header">sortedIndex</b><code>_.sortedIndex(array, value, [iteratee], [context])</code>
        <br>
        使用二分查找确定<b>value</b>在<b>list</b>中的位置序号，<b>value</b>按此序号插入能保持<b>list</b>原有的排序。如果提供 <a href="#iteratee"><b>iteratee</b></a> 函数，<b>iterator</b>将作为list排序的依据，包括你传递的<b>value</b> 。<b>iterator</b>也可以是字符串的属性名用来排序(比如<tt>length</tt>)。
    </p>
    <pre>_.sortedIndex([10, 20, 30, 40, 50], 35);
=&gt; 3

var stooges = [{name: 'moe', age: 40}, {name: 'curly', age: 60}];
_.sortedIndex(stooges, {name: 'larry', age: 50}, 'age');
=&gt; 1</pre>
    <p id="findIndex">
        <b class="header">findIndex</b><code>_.findIndex(array, predicate, [context])</code>
        <br>
        类似于<a href="#indexOf"><tt>_.indexOf</tt></a>，当<strong>predicate</strong>通过真检查时，返回第一个索引值；否则返回<i>-1</i>。
    </p>
    <pre>_.findIndex([4, 6, 8, 12], isPrime);
=&gt; -1 // not found
_.findIndex([4, 6, 7, 12], isPrime);
=&gt; 2</pre>
    <p id="findLastIndex">
        <b class="header">findLastIndex</b><code>_.findLastIndex(array, predicate, [context])</code>
        <br>
        和<a href="#findIndex"><tt>_.findIndex</tt></a>类似，但反向迭代数组，当<strong>predicate</strong>通过真检查时，最接近末端的索引值将被返回。
    </p>
    <pre>var users = [
  {'id': 1, 'name': 'Bob', 'last': 'Brown'},
  {'id': 2, 'name': 'Ted', 'last': 'White'},
  {'id': 3, 'name': 'Frank', 'last': 'James'},
  {'id': 4, 'name': 'Ted', 'last': 'Jones'}
];
_.findLastIndex(users, {
  name: 'Ted'
});
=&gt; 3</pre>
    <p id="range">
        <b class="header">range</b><code>_.range([start], stop, [step])</code>
        <br>
        一个用来创建整数灵活编号的列表的函数，便于<tt>each</tt> 和 <tt>map</tt>循环。如果省略<b>start</b>则默认为 <i>0</i>；<b>step</b> 默认为 <i>1</i>.返回一个从<b>start</b> 到<b>stop</b>的整数的列表，用<b>step</b>来增加 （或减少）独占。值得注意的是，如果<b>stop</b>值在<b>start</b>前面（也就是<b>stop</b>值小于<b>start</b>值），那么值域会被认为是零长度，而不是负增长。-如果你要一个负数的值域 ，请使用负数<b>step</b>.
    </p>
    <pre>_.range(10);
=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
_.range(1, 11);
=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
_.range(0, 30, 5);
=&gt; [0, 5, 10, 15, 20, 25]
_.range(0, -10, -1);
=&gt; [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
_.range(0);
=&gt; []</pre>
    <h2 id="functions">与函数有关的函数（Function (uh, ahem) Functions）</h2>
    <p id="bind">
        <b class="header">bind</b><code>_.bind(function, object, *arguments)</code>
        <br>
        绑定函数 <b>function</b> 到对象 <b>object</b> 上, 也就是无论何时调用函数, 函数里的 <i>this</i> 都指向这个 <b>object</b>.任意可选参数 <b>arguments</b> 可以传递给函数 <b>function</b> , 可以填充函数所需要的参数,这也被称为 <b>partial application</b>。对于没有结合上下文的<b>partial application</b>绑定，请使用<a href="#partial">partial</a>。
        <br>(注：partial application翻译成“部分应用”或者“偏函数应用”。partial application可以被描述为一个函数，它接受一定数目的参数，绑定值到一个或多个这些参数，并返回一个新的函数，这个返回函数只接受剩余未绑定值的参数。参见：<a href="http://en.wikipedia.org/wiki/Partial_application" target="_blank">http://en.wikipedia.org/wiki/Partial_application</a>。感谢<a href="http://weibo.com/u/2654434300" target="_blank">@一任风月忆秋年</a>的建议)。
    </p>
    <pre>var func = function(greeting){ return greeting + ': ' + this.name };
func = _.bind(func, {name: 'moe'}, 'hi');
func();
=&gt; 'hi: moe'</pre>
    <p id="bindAll">
        <b class="header">bindAll</b><code>_.bindAll(object, *methodNames)</code>
        <br>
        把<b>methodNames</b>参数指定的一些方法绑定到<b>object</b>上，这些方法就会在对象的上下文环境中执行。绑定函数用作事件处理函数时非常便利，否则函数被调用时<i>this</i>一点用也没有。<b>methodNames</b>参数是必须的。
    </p>
    <pre>var buttonView = {
  label  : 'underscore',
  onClick: function(){ alert('clicked: ' + this.label); },
  onHover: function(){ console.log('hovering: ' + this.label); }
};
_.bindAll(buttonView, 'onClick', 'onHover');
// When the button is clicked, this.label will have the correct value.
jQuery('#underscore_button').on('click', buttonView.onClick);</pre>
    <p id="partial">
        <b class="header">partial</b><code>_.partial(function, *arguments)</code>
        <br>
        局部应用一个函数填充在任意个数的 <b>arguments</b>，<i>不</i>改变其动态<tt>this</tt>值。和<a href="#bind">bind</a>方法很相近。你可以传递<tt>_</tt> 给<b>arguments</b>列表来指定一个不预先填充，但在调用时提供的参数。
    </p>
    <pre>var subtract = function(a, b) { return b - a; };
sub5 = _.partial(subtract, 5);
sub5(20);
=&gt; 15

// Using a placeholder
subFrom20 = _.partial(subtract, _, 20);
subFrom20(5);
=&gt; 15</pre>
    <p id="memoize">
        <b class="header">memoize</b><code>_.memoize(function, [hashFunction])</code>
        <br>
        Memoizes方法可以缓存某函数的计算结果。对于耗时较长的计算是很有帮助的。如果传递了 <b>hashFunction</b> 参数，就用 <b>hashFunction</b> 的返回值作为key存储函数的计算结果。<b>hashFunction</b> 默认使用function的第一个参数作为key。memoized值的缓存可作为返回函数的<tt>cache</tt>属性。
    </p>
    <pre>var fibonacci = _.memoize(function(n) {
  return n &lt; 2 ? n: fibonacci(n - 1) + fibonacci(n - 2);
});</pre>
    <p id="delay">
        <b class="header">delay</b><code>_.delay(function, wait, *arguments)</code>
        <br>
        类似<b>setTimeout</b>，等待<b>wait</b>毫秒后调用<b>function</b>。如果传递可选的参数<b>arguments</b>，当函数<b>function</b>执行时， <b>arguments</b> 会作为参数传入。
    </p>
    <pre>var log = _.bind(console.log, console);
_.delay(log, 1000, 'logged later');
=&gt; 'logged later' // Appears after one second.</pre>
    <p id="defer">
        <b class="header">defer</b><code>_.defer(function, *arguments)</code>
        <br>
        延迟调用<b>function</b>直到当前调用栈清空为止，类似使用延时为0的<b>setTimeout</b>方法。对于执行开销大的计算和无阻塞UI线程的HTML渲染时候非常有用。
        如果传递<b>arguments</b>参数，当函数<b>function</b>执行时， <b>arguments</b> 会作为参数传入。
    </p>
    <pre>_.defer(function(){ alert('deferred'); });
// Returns from the function before the alert runs.</pre>
    <p id="throttle">
        <b class="header">throttle</b><code>_.throttle(function, wait, [options])</code>
        <br>
        创建并返回一个像节流阀一样的函数，当重复调用函数的时候，至少每隔 <b>wait</b>毫秒调用一次该函数。对于想控制一些触发频率较高的事件有帮助。（注：详见：<a href="/archives/5256" target="_blank">javascript函数的throttle和debounce</a>，感谢
        <a href="http://weibo.com/u/3911878332" target="_blank">@澳利澳先生</a> 的翻译建议）
    </p>
    <p>
        默认情况下，<b>throttle</b>将在你调用的第一时间尽快执行这个<b>function</b>，并且，如果你在<b>wait</b>周期内调用任意次数的函数，都将尽快的被覆盖。如果你想禁用第一次首先执行的话，传递<tt>{leading: false}</tt>，还有如果你想禁用最后一次执行的话，传递<tt>{trailing: false}</tt>。
    </p>
    <pre>var throttled = _.throttle(updatePosition, 100);
$(window).scroll(throttled);</pre>
    <p>
        如果需要取消预定的 throttle ，可以在 throttle 函数上调用 <tt>.cancel()</tt>。
    </p>
    <p id="debounce">
        <b class="header">debounce</b><code>_.debounce(function, wait, [immediate])</code>
        <br>
        返回 <b>function</b> 函数的防反跳版本,
        将延迟函数的执行(真正的执行)在函数最后一次调用时刻的 <b>wait</b> 毫秒之后.
        对于必须在一些输入（多是一些用户操作）停止到达<i>之后</i>执行的行为有帮助。
        例如: 渲染一个Markdown格式的评论预览,
        当窗口停止改变大小之后重新计算布局, 等等.
    </p>
    <p>
        在 <b>wait</b> 间隔结束时，将使用<i>最近</i>传递给 debounced（去抖动）函数的参数调用该函数。
    </p>
    <p>
        传参 <b>immediate</b> 为 <tt>true</tt>， <b>debounce</b>会在 <b>wait</b> 时间间隔的开始调用这个函数
        。（注：并且在 waite 的时间之内，不会再次调用。）在类似不小心点了提交按钮两下而提交了两次的情况下很有用。
        （感谢
        <a href="http://weibo.com/u/1768962955" target="_blank">@ProgramKid </a> 的翻译建议）
    </p>
    <pre>var lazyLayout = _.debounce(calculateLayout, 300);
$(window).resize(lazyLayout);</pre>
    <p>
        如果需要取消预定的 debounce ，可以在 debounce 函数上调用 <tt>.cancel()</tt>。
    </p>
    <p id="once">
        <b class="header">once</b><code>_.once(function)</code>
        <br>
        创建一个只能调用一次的函数。重复调用改进的方法也没有效果，只会返回第一次执行时的结果。
        作为初始化函数使用时非常有用, 不用再设一个boolean值来检查是否已经初始化完成.
    </p>
    <pre>var initialize = _.once(createApplication);
initialize();
initialize();
// Application is only created once.</pre>
    <p id="after">
        <b class="header">after</b><code>_.after(count, function)</code>
        <br>
        创建一个函数, 只有在运行了 <b>count</b> 次之后才有效果.
        在处理同组异步请求返回结果时, 如果你要确保同组里所有异步请求完成之后才
        执行这个函数, 这将非常有用。
    </p>
    <pre>var renderNotes = _.after(notes.length, render);
_.each(notes, function(note) {
  note.asyncSave({success: renderNotes});
});
// renderNotes is run once, after all notes have saved.</pre>
    <p id="before">
        <b class="header">before</b><code>_.before(count, function)</code>
        <br>
        创建一个函数,调用不超过<b>count</b> 次。 当<b>count</b>已经达到时，最后一个函数调用的结果将被记住并返回。
    </p>
    <pre>var monthlyMeeting = _.before(3, askForRaise);
monthlyMeeting();
monthlyMeeting();
monthlyMeeting();
// the result of any subsequent calls is the same as the second call</pre>
    <p id="wrap">
        <b class="header">wrap</b><code>_.wrap(function, wrapper)</code>
        <br>
        将第一个函数 <b>function</b> 封装到函数 <b>wrapper</b> 里面,
        并把函数 <b>function</b> 作为第一个参数传给 <b>wrapper</b>.
        这样可以让 <b>wrapper</b> 在 <b>function</b> 运行之前和之后
        执行代码, 调整参数然后附有条件地执行。
    </p>
    <pre>var hello = function(name) { return "hello: " + name; };
hello = _.wrap(hello, function(func) {
  return "before, " + func("moe") + ", after";
});
hello();
=&gt; 'before, hello: moe, after'</pre>
    <p id="negate">
        <b class="header">negate</b><code>_.negate(predicate)</code>
        <br>
        返回一个新的<b>predicate</b>函数的否定版本。
    </p>
    <pre>var isFalsy = _.negate(Boolean);
_.find([-2, -1, 0, 1, 2], isFalsy);
=&gt; 0</pre>
    <p id="compose">
        <b class="header">compose</b><code>_.compose(*functions)</code>
        <br>
        返回函数集 <b>functions</b> 组合后的复合函数,
        也就是一个函数执行完之后把返回的结果再作为参数赋给下一个函数来执行.
        以此类推.
        在数学里, 把函数 <i>f()</i>, <i>g()</i>, 和 <i>h()</i> 组合起来可以得到复合函数 <i>f(g(h()))</i>。
    </p>
    <pre>var greet    = function(name){ return "hi: " + name; };
var exclaim  = function(statement){ return statement.toUpperCase() + "!"; };
var welcome = _.compose(greet, exclaim);
welcome('moe');
=&gt; 'hi: MOE!'</pre>
    <p id="restArguments">
        <b class="header">restArguments</b><code>_.restArguments(function, [startIndex])</code>
        <br>
        返回 <b>function</b> 的一个版本，该函数版本在调用时接收来自 <b>startIndex</b> 的所有参数，并将其收集到单个数组中。 如果未传递显式的 <b>startIndex</b> ，则将通过查看 <b>function</b> 本身的参数数来确定。 与 ES6 的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters">rest参数语法</a>类似。
    </p>
    <pre>var raceResults = _.restArguments(function(gold, silver, bronze, everyoneElse) {
  _.each(everyoneElse, sendConsolations);
});

raceResults("Dopey", "Grumpy", "Happy", "Sneezy", "Bashful", "Sleepy", "Doc");</pre>
    <h2 id="objects">对象函数（Object Functions）</h2>
    <p id="keys">
        <b class="header">keys</b><code>_.keys(object)</code>
        <br>
        检索<b>object</b>拥有的所有可枚举属性的名称。
    </p>
    <pre>_.keys({one: 1, two: 2, three: 3});
=&gt; ["one", "two", "three"]</pre>
    <p id="allKeys">
        <b class="header">allKeys</b><code>_.allKeys(object)</code>
        <br>
        检索<b>object</b>拥有的和继承的所有属性的名称。
    </p>
    <pre>function Stooge(name) {
  this.name = name;
}
Stooge.prototype.silly = true;
_.allKeys(new Stooge("Moe"));
=&gt; ["name", "silly"]</pre>
    <p id="values">
        <b class="header">values</b><code>_.values(object)</code>
        <br>
        返回<b>object</b>对象所有的属性值。
    </p>
    <pre>_.values({one: 1, two: 2, three: 3});
=&gt; [1, 2, 3]</pre>
    <p id="mapObject">
        <b class="header">mapObject</b><code>_.mapObject(object, iteratee, [context])</code>
        <br>
        它类似于<a href="#map">map</a>，但是这用于对象。转换每个属性的值。
    </p>
    <pre>_.mapObject({start: 5, end: 12}, function(val, key) {
  return val + 5;
});
=&gt; {start: 10, end: 17}</pre>
    <p id="pairs">
        <b class="header">pairs</b><code>_.pairs(object)</code>
        <br>
        把一个对象转变为一个<tt>[key, value]</tt>形式的数组。<a href="#object">object</a> 逆向函数。
    </p>
    <pre>_.pairs({one: 1, two: 2, three: 3});
=&gt; [["one", 1], ["two", 2], ["three", 3]]</pre>
    <p id="invert">
        <b class="header">invert</b><code>_.invert(object)</code>
        <br>
        返回一个<b>object</b>副本，使其键（keys）和值（values）对换。对于这个操作，必须确保object里所有的值都是唯一的且可以序列号成字符串.
    </p>
    <pre>_.invert({Moe: "Moses", Larry: "Louis", Curly: "Jerome"});
=&gt; {Moses: "Moe", Louis: "Larry", Jerome: "Curly"};</pre>
    <p id="create">
        <b class="header">create</b><code>_.create(prototype, props)</code>
        <br>
        创建具有给定原型的新对象，可选附加<b>props</b> 作为 <i>own</i>的属性。基本上，和<tt>Object.create</tt>一样，但是没有所有的属性描述符。
    </p>
    <pre>var moe = _.create(Stooge.prototype, {name: "Moe"});</pre>
    <p id="object-functions">
        <b class="header">functions</b><code>_.functions(object)</code>
        <span class="alias">Alias: <b>methods</b></span>
        <br>
        返回一个对象里所有的方法名, 而且是已经排序的 — 也就是说, 对象里每个方法(属性值是一个函数)的名称.
    </p>
    <pre>_.functions(_);
=&gt; ["all", "any", "bind", "bindAll", "clone", "compact", "compose" ...</pre>
    <p id="findKey">
        <b class="header">findKey</b><code>_.findKey(object, predicate, [context])</code>
        <br>
        类似于<a href="#findIndex"><tt>_.findIndex</tt></a> ，但用于对象中的 key（键）。返回通过<b>predicate</b> 真值测试的 <i>key</i> ，否则返回 <i>undefined</i> 。
        <b>predicate</b> 通过 <a href="#iteratee"><b>iteratee</b></a> 进行转换，以简化速记语法。
    </p>
    <p id="extend">
        <b class="header">extend</b><code>_.extend(destination, *sources)</code>
        <br>
        将<b>source</b>对象中的所有属性简单地覆盖到<b>destination</b>对象上，并且返回 <b>destination</b> 对象. 复制是按顺序的, 所以后面的对象属性会把前面的对象属性覆盖掉(如果有重复)。
    </p>
    <pre>_.extend({name: 'moe'}, {age: 50});
=&gt; {name: 'moe', age: 50}</pre>
    <p id="extendOwn">
        <b class="header">extendOwn</b><code>_.extendOwn(destination, *sources)</code>
        <span class="alias">Alias: <b>assign</b></span>
        <br>
        类似于 <b>extend</b>, 但只复制<i>自己的</i>属性覆盖到目标对象。（注：不包括继承过来的属性）。
    </p>
    <p id="pick">
        <b class="header">pick</b><code>_.pick(object, *keys)</code>
        <br>
        返回一个<b>object</b>副本，只过滤出<b>keys</b>(有效的键组成的数组)参数指定的属性值。或者接受一个判断函数，指定挑选哪个key。
    </p>
    <pre>_.pick({name: 'moe', age: 50, userid: 'moe1'}, 'name', 'age');
=&gt; {name: 'moe', age: 50}
_.pick({name: 'moe', age: 50, userid: 'moe1'}, function(value, key, object) {
  return _.isNumber(value);
});
=&gt; {age: 50}</pre>
    <p id="omit">
        <b class="header">omit</b><code>_.omit(object, *keys)</code>
        <br>
        返回一个<b>object</b>副本，只过滤出除去<b>keys</b>(有效的键组成的数组)参数指定的属性值。
        或者接受一个判断函数，指定忽略哪个key。
    </p>
    <pre>_.omit({name: 'moe', age: 50, userid: 'moe1'}, 'userid');
=&gt; {name: 'moe', age: 50}
_.omit({name: 'moe', age: 50, userid: 'moe1'}, function(value, key, object) {
  return _.isNumber(value);
});
=&gt; {name: 'moe', userid: 'moe1'}</pre>
    <p id="defaults">
        <b class="header">defaults</b><code>_.defaults(object, *defaults)</code>
        <br>
        用<b>defaults</b>对象填充<b>object</b> 中的<tt>undefined</tt>属性。 并且返回这个<b>object</b>。一旦这个属性被填充，再使用defaults方法将不会有任何效果。（感谢<a title="一任风月忆秋年" usercard="id=2654434300" href="http://weibo.com/u/2654434300">@一任风月忆秋年</a>的拍砖）
    </p>
    <pre>var iceCream = {flavor: "chocolate"};
_.defaults(iceCream, {flavor: "vanilla", sprinkles: "lots"});
=&gt; {flavor: "chocolate", sprinkles: "lots"}</pre>
    <p id="clone">
        <b class="header">clone</b><code>_.clone(object)</code>
        <br>
        创建 一个浅复制（浅拷贝）的克隆<b>object</b>。任何嵌套的对象或数组都通过引用拷贝，不会复制。
    </p>
    <pre>_.clone({name: 'moe'});
=&gt; {name: 'moe'};</pre>
    <p id="tap">
        <b class="header">tap</b><code>_.tap(object, interceptor)</code>
        <br>
        用 <b>object</b>作为参数来调用函数<b>interceptor</b>，然后返回<b>object</b>。这种方法的主要意图是作为函数链式调用 的一环, 为了对此对象执行操作并返回对象本身。
    </p>
    <pre>_.chain([1,2,3,200])
.filter(function(num) { return num % 2 == 0; })
.tap(alert)
.map(function(num) { return num * num })
.value();
=&gt; // [2, 200] (alerted)
=&gt; [4, 40000]</pre>
    <p id="has">
        <b class="header">has</b><code>_.has(object, key)</code>
        <br>
        对象是否包含给定的键吗？等同于<tt>object.hasOwnProperty(key)</tt>，但是使用<tt>hasOwnProperty</tt> 函数的一个安全引用，以防<a href="http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/">意外覆盖</a>。
    </p>
    <pre>_.has({a: 1, b: 2, c: 3}, "b");
=&gt; true</pre>
    <p id="property">
        <b class="header">property</b><code>_.property(path)</code>
        <br>
        返回一个函数，该函数将返回任何传入对象的指定属性。 <tt>path</tt> 可以指定为简单 key（键），或者指定为对象键或数组索引的数组，用于深度属性提取。
    </p>
    <pre>var stooge = {name: 'moe'};
'moe' === _.property('name')(stooge);
=&gt; true

var stooges = {moe: {fears: {worst: 'Spiders'}}, curly: {fears: {worst: 'Moe'}}};
var curlysWorstFear = _.property(['curly', 'fears', 'worst']);
curlysWorstFear(stooges);
=&gt; 'Moe'</pre>
    <p id="propertyOf">
        <b class="header">propertyOf</b><code>_.propertyOf(object)</code>
        <br>
        <tt>_.property</tt> 的反操作。 获取一个对象并返回一个函数，该函数将返回提供的属性的值。
    </p>
    <pre>var stooge = {name: 'moe'};
_.propertyOf(stooge)('name');
=&gt; 'moe'</pre>
    <p id="matcher">
        <b class="header">matcher</b><code>_.matcher(attrs)</code>
        <span class="alias">Alias: <b>matches</b></span>
        <br>
        返回一个断言函数，这个函数会给你一个断言可以用来辨别给定的对象是否匹配<b>attrs</b>指定键/值属性。
    </p>
    <pre>var ready = _.matcher({selected: true, visible: true});
var readyToGoList = _.filter(list, ready);</pre>
    <p id="isEqual">
        <b class="header">isEqual</b><code>_.isEqual(object, other)</code>
        <br>
        执行两个对象之间的优化深度比较，确定他们是否应被视为相等。
    </p>
    <pre>var stooge = {name: 'moe', luckyNumbers: [13, 27, 34]};
var clone  = {name: 'moe', luckyNumbers: [13, 27, 34]};
stooge == clone;
=&gt; false
_.isEqual(stooge, clone);
=&gt; true</pre>
    <p id="isMatch">
        <b class="header">isMatch</b><code>_.isMatch(object, properties)</code>
        <br>
        告诉你<b>properties</b>中的键和值是否包含在<b>object</b>中。
    </p>
    <pre>var stooge = {name: 'moe', age: 32};
_.isMatch(stooge, {age: 32});
=&gt; true</pre>
    <p id="isEmpty">
        <b class="header">isEmpty</b><code>_.isEmpty(object)</code>
        <br>
        如果<b>object</b> 不包含任何值(没有可枚举的属性)，返回<i>true</i>。
        对于字符串和类数组（array-like）对象，如果length属性为 0，那么<tt>_.isEmpty</tt>检查返回<i>true</i>。
    </p>
    <pre>_.isEmpty([1, 2, 3]);
=&gt; false
_.isEmpty({});
=&gt; true</pre>
    <p id="isElement">
        <b class="header">isElement</b><code>_.isElement(object)</code>
        <br>
        如果<b>object</b>是一个DOM元素，返回<i>true</i>。
    </p>
    <pre>_.isElement(jQuery('body')[0]);
=&gt; true</pre>
    <p id="isArray">
        <b class="header">isArray</b><code>_.isArray(object)</code>
        <br>
        如果<b>object</b>是一个数组，返回<i>true</i>。
    </p>
    <pre>(function(){ return _.isArray(arguments); })();
=&gt; false
_.isArray([1,2,3]);
=&gt; true</pre>
    <p id="isObject">
        <b class="header">isObject</b><code>_.isObject(value)</code>
        <br>
        如果<b>object</b>是一个对象，返回<i>true</i>。需要注意的是JavaScript数组和函数是对象，字符串和数字不是。
    </p>
    <pre>_.isObject({});
=&gt; true
_.isObject(1);
=&gt; false</pre>
    <p id="isArguments">
        <b class="header">isArguments</b><code>_.isArguments(object)</code>
        <br>
        如果<b>object</b>是一个参数对象，返回<i>true</i>。
    </p>
    <pre>(function(){ return _.isArguments(arguments); })(1, 2, 3);
=&gt; true
_.isArguments([1,2,3]);
=&gt; false</pre>
    <p id="isFunction">
        <b class="header">isFunction</b><code>_.isFunction(object)</code>
        <br>
        如果<b>object</b>是一个函数（Function），返回<i>true</i>。
    </p>
    <pre>_.isFunction(alert);
=&gt; true</pre>
    <p id="isString">
        <b class="header">isString</b><code>_.isString(object)</code>
        <br>
        如果<b>object</b>是一个字符串，返回<i>true</i>。
    </p>
    <pre>_.isString("moe");
=&gt; true</pre>
    <p id="isNumber">
        <b class="header">isNumber</b><code>_.isNumber(object)</code>
        <br>
        如果<b>object</b>是一个数值，返回<i>true</i> (包括 <tt>NaN</tt>)。
    </p>
    <pre>_.isNumber(8.4 * 5);
=&gt; true</pre>
    <p id="isFinite">
        <b class="header">isFinite</b><code>_.isFinite(object)</code>
        <br>
        如果<b>object</b>是一个有限的数字，返回<i>true</i>。
    </p>
    <pre>_.isFinite(-101);
=&gt; true

_.isFinite(-Infinity);
=&gt; false</pre>
    <p id="isBoolean">
        <b class="header">isBoolean</b><code>_.isBoolean(object)</code>
        <br>
        如果<b>object</b>是一个布尔值，返回<i>true</i>，否则返回<i>false</i>。
    </p>
    <pre>_.isBoolean(null);
=&gt; false</pre>
    <p id="isDate">
        <b class="header">isDate</b><code>_.isDate(object)</code>
        <br>
        如果<b>object</b>是一个 Date（日期），返回<i>true</i>。
    </p>
    <pre>_.isDate(new Date());
=&gt; true</pre>
    <p id="isRegExp">
        <b class="header">isRegExp</b><code>_.isRegExp(object)</code>
        <br>
        如果<b>object</b>是一个正则表达式，返回<i>true</i>。
    </p>
    <pre>_.isRegExp(/moe/);
=&gt; true</pre>
    <p id="isError">
        <b class="header">isError</b><code>_.isError(object)</code>
        <br>
        如果<b>object</b>继承至 Error 对象，那么返回 <i>true</i>。
    </p>
    <pre>try {
  throw new TypeError("Example");
} catch (o_O) {
  _.isError(o_O);
}
=&gt; true</pre>
    <p id="isSymbol">
        <b class="header">isSymbol</b><code>_.isSymbol(object)</code>
        <br>
        如果<b>object</b>是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a> ，那么返回 <i>true</i>。
    </p>
    <pre>_.isSymbol(Symbol());
    =&gt; true</pre>
    <p id="isMap">
        <b class="header">isMap</b><code>_.isMap(object)</code>
        <br>
        如果<b>object</b>是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> ，那么返回 <i>true</i>。
    </p>
    <pre>_.isMap(new Map());
=&gt; true</pre>
    <p id="isWeakMap">
        <b class="header">isWeakMap</b><code>_.isWeakMap(object)</code>
        <br>
        如果<b>object</b>是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMap</a>，那么返回 <i>true</i>。
    </p>
    <pre>_.isWeakMap(new WeakMap());
=&gt; true</pre>
    <p id="isSet">
        <b class="header">isSet</b><code>_.isSet(object)</code>
        <br>
        如果<b>object</b>是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a>，那么返回 <i>true</i>。
    </p>
    <pre>_.isSet(new Set());
=&gt; true</pre>
    <p id="isWeakSet">
        <b class="header">isWeakSet</b><code>_.isWeakSet(object)</code>
        <br>
        如果<b>object</b>是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet">WeakSet</a>，那么返回 <i>true</i>。
    </p>
    <pre>_.isWeakSet(WeakSet());
=&gt; true</pre>
    <p id="isNaN">
        <b class="header">isNaN</b><code>_.isNaN(object)</code>
        <br>
        如果<b>object</b>是 <i>NaN</i>，返回<i>true</i>。
        <br> 注意： 这和原生的<b>isNaN</b> 函数不一样，如果变量是<i>undefined</i>，原生的<b>isNaN</b> 函数也会返回 <i>true</i> 。
    </p>
    <pre>_.isNaN(NaN);
=&gt; true
isNaN(undefined);
=&gt; true
_.isNaN(undefined);
=&gt; false</pre>
    <p id="isNull">
        <b class="header">isNull</b><code>_.isNull(object)</code>
        <br>
        如果<b>object</b>的值是 <i>null</i>，返回<i>true</i>。
    </p>
    <pre>_.isNull(null);
=&gt; true
_.isNull(undefined);
=&gt; false</pre>
    <p id="isUndefined">
        <b class="header">isUndefined</b><code>_.isUndefined(value)</code>
        <br>
        如果<b>value</b>是<i>undefined</i>，返回<i>true</i>。
    </p>
    <pre>_.isUndefined(window.missingVariable);
=&gt; true</pre>
    <h2 id="utility">实用功能(Utility Functions) </h2>
    <p id="noConflict">
        <b class="header">noConflict</b><code>_.noConflict()</code>
        <br>
        放弃<b>Underscore</b> 的控制变量 <tt>_</tt>。返回<b>Underscore</b> 对象的引用。
    </p>
    <pre>var underscore = _.noConflict();</pre>
    <p id="identity">
        <b class="header">identity</b><code>_.identity(value)</code>
        <br>
        返回与传入参数相等的值. 相当于数学里的: <tt>f(x) = x</tt><br>
        这个函数看似无用, 但是在Underscore里被用作默认的迭代器iterator.
    </p>
    <pre>var stooge = {name: 'moe'};
stooge === _.identity(stooge);
=&gt; true</pre>
    <p id="constant">
        <b class="header">constant</b><code>_.constant(value)</code>
        <br>
        创建一个函数，这个函数 返回相同的值 用来作为<tt>_.constant</tt>的参数。
    </p>
    <pre>var stooge = {name: 'moe'};
stooge === _.constant(stooge)();
=&gt; true</pre>
    <p id="noop">
        <b class="header">noop</b><code>_.noop()</code>
        <br>
        返回<tt>undefined</tt>，不论传递给它的是什么参数。 可以用作默认可选的回调参数。
    </p>
    <pre>obj.initialize = _.noop;</pre>
    <p id="times">
        <b class="header">times</b><code>_.times(n, iteratee, [context])</code>
        <br>
        调用给定的迭代函数<b>n</b>次,每一次调用<b>iteratee</b>传递<tt>index</tt>参数。生成一个返回值的数组。
    </p>
    <pre>_.times(3, function(n){ genie.grantWishNumber(n); });</pre>
    <p id="random">
        <b class="header">random</b><code>_.random(min, max)</code>
        <br>
        返回一个<b>min</b> 和 <b>max</b>之间的随机整数。如果你只传递一个参数，那么将返回<tt>0</tt>和这个参数之间的整数。
    </p>
    <pre>_.random(0, 100);
=&gt; 42</pre>
    <p id="mixin">
        <b class="header">mixin</b><code>_.mixin(object)</code>
        <br>
        允许用您自己的实用程序函数扩展Underscore。传递一个 <tt>{name: function}</tt>定义的哈希添加到Underscore对象，以及面向对象封装。
    </p><pre>_.mixin({
capitalize: function(string) {
  return string.charAt(0).toUpperCase() + string.substring(1).toLowerCase();
}
});
_("fabio").capitalize();
=&gt; "Fabio"</pre>
    <p id="iteratee">
        <b class="header">iteratee</b><code>_.iteratee(value, [context])</code>
        <br>
        生成可应用于集合中的每个元素的回调。<tt>_.iteratee</tt>支持许多常见回调用例的简写语法。根据值的类型，<tt>_.iteratee</tt> 将返回：
    </p>
    <pre>// No value
_.iteratee();
=&gt; _.identity()

// Function
_.iteratee(function(n) { return n * 2; });
=&gt; function(n) { return n * 2; }

// Object
_.iteratee({firstName: 'Chelsea'});
=&gt; _.matcher({firstName: 'Chelsea'});

// Anything else
_.iteratee('firstName');
=&gt; _.property('firstName');</pre>
    <p>
        通过<tt>_.iteratee</tt>转换判断的Underscore 方法的完整列表是: <tt>countBy</tt>, <tt>every</tt>,
        <tt>filter</tt>, <tt>find</tt>, <tt>findIndex</tt>, <tt>findKey</tt>,
        <tt>findLastIndex</tt>, <tt>groupBy</tt>, <tt>indexBy</tt>,
        <tt>map</tt>, <tt>mapObject</tt>, <tt>max</tt>, <tt>min</tt>,
        <tt>partition</tt>, <tt>reject</tt>, <tt>some</tt>, <tt>sortBy</tt>,
        <tt>sortedIndex</tt>, and <tt>uniq</tt>
    </p>
    <p>
        如果您需要其他或不同的简写语法，可以使用自己的自定义函数覆盖 <tt>_.iteratee</tt>：
    </p>
    <pre>// Support `RegExp` predicate shorthand.
var builtinIteratee = _.iteratee;
_.iteratee = function(value, context) {
  if (_.isRegExp(value)) return function(obj) { return value.test(obj) };
  return builtinIteratee(value, context);
};</pre>
    <p id="uniqueId">
        <b class="header">uniqueId</b><code>_.uniqueId([prefix])</code>
        <br>
        为需要的客户端模型或DOM元素生成一个全局唯一的id。如果<b>prefix</b>参数存在， id 将附加给它。
    </p>
    <pre>_.uniqueId('contact_');
=&gt; 'contact_104'</pre>
    <p id="escape">
        <b class="header">escape</b><code>_.escape(string)</code>
        <br>
        转义HTML字符串，替换<tt>&amp;</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>"</tt>, <tt>'</tt>, 和 <tt>/</tt>字符。
    </p>
    <pre>_.escape('Curly, Larry &amp; Moe');
=&gt; "Curly, Larry &amp;amp; Moe"</pre>
    <p id="unescape">
        <b class="header">unescape</b><code>_.unescape(string)</code>
        <br>
        和<a href="#escape"><b>escape</b></a>相反。转义HTML字符串，替换<tt>&amp;</tt>, <tt>&amp;lt;</tt>, <tt>&amp;gt;</tt>, <tt>&amp;quot;</tt>, <tt>&amp;#96;</tt>, 和 <tt>&amp;#x2F;</tt>字符。
    </p>
    <pre>_.unescape('Curly, Larry &amp;amp; Moe');
=&gt; "Curly, Larry &amp; Moe"</pre>
    <p id="result">
        <b class="header">result</b><code>_.result(object, property, [defaultValue])</code>
        <br>
        如果指定的<b>property</b> 的值是一个函数，那么将在<b>object</b>上下文内调用它;否则，返回它。如果提供默认值，并且属性不存在，那么默认值将被返回。如果设置<tt>defaultValue</tt>是一个函数，它的结果将被返回。
    </p>
    <pre>var object = {cheese: 'crumpets', stuff: function(){ return 'nonsense'; }};
_.result(object, 'cheese');
=&gt; "crumpets"
_.result(object, 'stuff');
=&gt; "nonsense"
_.result(object, 'meat', 'ham');
=&gt; "ham"</pre>
    <p id="now">
        <b class="header">now</b><code>_.now()</code>
        <br>
        一个优化的方式来获得一个当前时间的整数时间戳。可用于实现定时/动画功能。
    </p>
    <pre>_.now();
=&gt; 1392066795351</pre>
    <p id="template">
        <b class="header">template</b><code>_.template(templateString, [settings])</code>
        <br>
        将 JavaScript 模板编译为可以用于页面呈现的函数, 对于通过JSON数据源生成复杂的HTML并呈现出来的操作非常有用。
        模板函数可以使用
        <tt>&lt;%= … %&gt;</tt>插入变量, 也可以用<tt>&lt;% … %&gt;</tt>执行任意的 JavaScript 代码。
        如果您希望插入一个值, 并让其进行HTML转义,请使用<tt>&lt;%- … %&gt;</tt>。
        当你要给模板函数赋值的时候，可以传递一个含有与模板对应属性的<b>data</b>对象 。
        如果您要写一个一次性的, 您可以传对象 <b>data</b>
        作为第二个参数给模板 <b>template</b> 来直接呈现,
        这样页面会立即呈现而不是返回一个模板函数.
        参数 <b>settings</b> 是一个哈希表包含任何可以覆盖的设置 <tt>_.templateSettings</tt>.
    </p>
    <pre>var compiled = _.template("hello: &lt;%= name %&gt;");
compiled({name: 'moe'});
=&gt; "hello: moe"

var template = _.template("&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;");
template({value: '&lt;script&gt;'});
=&gt; "&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;"</pre>
    <p>
        您也可以在 JavaScript 代码中使用 <tt>print</tt>.
        有时候这会比使用 <tt>&lt;%= ... %&gt;</tt> 更方便.
    </p>
    <pre>var compiled = _.template("&lt;% print('Hello ' + epithet); %&gt;");
compiled({epithet: "stooge"});
=&gt; "Hello stooge"</pre>
    <p>如果ERB式的分隔符您不喜欢, 您可以改变Underscore的模板设置, 使用别的符号来嵌入代码.定义一个 <b>interpolate</b> 正则表达式来逐字匹配嵌入代码的语句, 如果想插入转义后的HTML代码则需要定义一个 <b>escape</b> 正则表达式来匹配,还有一个 <b>evaluate</b> 正则表达式来匹配您想要直接一次性执行程序而不需要任何返回值的语句.您可以定义或省略这三个的任意一个.例如, 要执行<a href="http://github.com/janl/mustache.js#readme">Mustache.js</a>类型的模板:
    </p>
    <pre>_.templateSettings = {
interpolate: /\{\{(.+?)\}\}/g
};

var template = _.template("Hello {{ name }}!");
template({name: "Mustache"});
=&gt; "Hello Mustache!"</pre>
    <p>
        默认的, <b>template</b> 通过 <tt>with</tt> 语句来取得 data 所有的值. 当然, 您也可以在 <b>variable</b> 设置里指定一个变量名. 这样能显著提升模板的渲染速度.
    </p>
    <pre>_.template("Using 'with': &lt;%= data.answer %&gt;", {variable: 'data'})({answer: 'no'});
=&gt; "Using 'with': no"</pre>
    <p>
        预编译模板对调试不可重现的错误很有帮助.
        这是因为预编译的模板可以提供错误的代码行号和堆栈跟踪,
        有些模板在客户端(浏览器)上是不能通过编译的
        在编译好的模板函数上, 有 <b>source</b>
        属性可以提供简单的预编译功能.
    </p>
    <pre>&lt;script&gt;
JST.project = &lt;%= _.template(jstText).source %&gt;;
&lt;/script&gt;</pre>
    <h2 id="oop">Object-Oriented Style</h2>
    <p>
        您可以在面向对象或者函数的风格下使用Underscore,
        这取决于您的个人偏好. 以下两行代码都可以
        把一个数组里的所有数字乘以2.
    </p>
    <pre>_.map([1, 2, 3], function(n){ return n * 2; });
_([1, 2, 3]).map(function(n){ return n * 2; });</pre>
    <h2 id="chaining">链式语法(Chaining)</h2>
    <p>
        对一个对象使用 <tt>chain</tt> 方法, 会把这个对象封装并
        让以后每次方法的调用结束后都返回这个封装的对象, 当您完成了计算,
        可以使用 <tt>value</tt> 函数来取得最终的值.
        以下是一个同时使用了 <b>map/flatten/reduce</b>
        的链式语法例子, 目的是计算一首歌的歌词里每一个单词出现的次数.
    </p>
    <pre>var lyrics = [
{line: 1, words: "I'm a lumberjack and I'm okay"},
{line: 2, words: "I sleep all night and I work all day"},
{line: 3, words: "He's a lumberjack and he's okay"},
{line: 4, words: "He sleeps all night and he works all day"}
];

_.chain(lyrics)
.map(function(line) { return line.words.split(' '); })
.flatten()
.reduce(function(counts, word) {
  counts[word] = (counts[word] || 0) + 1;
  return counts;
}, {})
.value();

=&gt; {lumberjack: 2, all: 4, night: 2 ... }</pre>
    <p>
        此外, <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/prototype">数组原型方法</a>
        也通过代理加入到了链式封装的Underscore对象, 所以您可以
        在链式语法中直接使用 <tt>reverse</tt> 或 <tt>push</tt> 方法,
        然后再接着其他的语句.
    </p>
    <p id="chain">
        <b class="header">chain</b><code>_.chain(obj)</code>
        <br>
        返回一个封装的对象. 在封装的对象上调用方法会返回封装的对象本身,
        直道 <tt>value</tt> 方法调用为止。
    </p>
    <pre>var stooges = [{name: 'curly', age: 25}, {name: 'moe', age: 21}, {name: 'larry', age: 23}];
var youngest = _.chain(stooges)
.sortBy(function(stooge){ return stooge.age; })
.map(function(stooge){ return stooge.name + ' is ' + stooge.age; })
.first()
.value();
    =&gt; "moe is 21"</pre>
    <p id="value">
        <b class="header">value</b><code>_.chain(obj).value()</code>
        <br>
        获取封装对象的最终值。
    </p>
    <pre>_.chain([1, 2, 3]).reverse().value();
=&gt; [3, 2, 1]</pre>
            </div>
  </div>
</body>

</html>